# 计算机网络

参考资料：

- https://www.runoob.com/html/html5-websocket.html
- https://blog.csdn.net/wx_962464/article/details/51043069
- https://www.zhihu.com/question/338939262/answer/778573750
- https://github.com/abbshr/abbshr.github.io/issues/22

## SSL

### 总述

SSL称为**安全套接字协议**，是为网络通信提供安全及数据完整性的一种安全协议。SSL在传输层与应用层之间对网络连接进行加密。位于端口**443**。

### 对称加密和非对称加密

我们要想了解SSL，首先得了解对称加密和非对称加密。

#### 对称加密

##### 描述

需要对加密和解密使用相同密钥的加密算法。

例如：

假设有一个加密算法A, 这个算法将每一位的ASCII码加2形成密文。

用户甲: 明文 ABCD  **-- 加密 -->**  密文 CDEF 

用户乙: 密文CDEF  **-- 解密 -->**  明文 ABCD

我们可以发现，对称加密需要对加密和解密使用相同密钥（可以看成加解密的指令）的加密算法。它的安全性去决议加密算法和密钥的管理。

##### 优缺点

效率高，由于不适合在网上传输，秘钥的维护较为麻烦。

#### 非对称加密

##### 描述

非对称加密算法需要两个密钥：公开密钥（publickey，简称公钥）和私有密钥（privatekey，简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

例如：

- A要向B发送信息，A和B都要产生一对用于加密和解密的**公钥和私钥**。
- A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。
- A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。
- A将这个消息发给B（已经用B的公钥加密消息）
- B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。

##### 优缺点

有较高的安全性，但效率低。

一个优化方案是**结合对称加密算法**，例如如果数据比较大，使用对方的公钥来加密效率会很低，但是我们可以使用对称秘钥，但是使用对方的公钥来加密这个对称秘钥，就可以提高效率（因为加密这个数据量不算大的公钥效率高），这些描述可以概括为“**给锁上锁**”。

### SSL的过程

上面说到，SSL在传输层与应用层之间对网络连接进行加密。

在发送方，SSL接收应用层的数据，对数据进行加密，然后把加密的数据送往TCP套接字。

在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层。

浏览器在访问web服务器的资源时，安装了**证书**的web服务器会交给浏览器一个公钥，之后浏览器生成一个对称加密秘钥，然后用web服务器的公钥进行加密，web服务器可以对这个对称加密秘钥进行解密。在此之后，浏览器和web服务器就通过这个对称加密秘钥来通信。

 ### 数字证书

#### 总述

对于请求方来说，它怎么能确定它所得到的公钥一定是从目标主机那里发布的，而且没有被篡改过呢？亦或者请求的目标主机本本身就从事窃取用户信息的不正当行为呢？这时候，我们需要有一个权威的值得信赖的第三方机构(一般是由政府审核并授权的机构)来统一对外发放主机机构的公钥，只要请求方这种机构获取公钥，就避免了上述问题的发生。

#### 颁发过程

用户首先**产生自己的密钥对**，并将公共密钥及部分个人身份信息传送给认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个**数字证书**，该证书内包含**用户的个人信息和他的公钥信息**，同时还附有认证中心的**签名信息**(根证书私钥签名)。用户就可以使用自己的数字证书进行相关的各种活动。数字证书由独立的证书发行机构发布，数字证书各不相同，每种证书可提供不同级别的可信度。

#### 如何验证

浏览器/操作系统默认内置了CA的根证书。根证书包含了这个CA的公钥。

如果:

- 证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书

- 如果伪造的证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。用CA的公钥，对伪造的证书的摘要进行解密，发现解不了, 认为是危险证书。

- 对于篡改的证书，使用CA的公钥对数字签名进行解密得到摘要A,然后再根据签名的Hash算法计算出证书的摘要B，对比A与B，若相等则正常，若不相等则是被篡改过的。

- 证书可在其过期前被吊销，通常情况是该证书的私钥已经失密。较新的浏览器如Chrome、Firefox、Opera和Internet Explorer都实现了在线证书状态协议（OCSP）以排除这种情形：浏览器将网站提供的证书的序列号通过OCSP发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。

## HTTP状态码

### 分类

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型。

| 分类 | 分类描述                                           |
| :--- | :------------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要**请求者继续执行操作**   |
| 2**  | **成功**，操作被成功接收并处理                     |
| 3**  | **重定向**，需要进一步的操作以完成请求             |
| 4**  | **客户端错误**，请求包含语法错误或无法完成请求     |
| 5**  | **服务器错误**，服务器在处理请求的过程中发生了错误 |

### 常见的状态码

| HTTP状态码 | 英文名称      | 中文描述                                                     |
| :--------- |------------------------ | :----------------------------------------------------------- |
| 100 | Continue | 客户端征询服务器状况，如果服务器同意可以返回100，同时客户端可以继续请求。常见的案例是在上传大文件的情况下，客户端先上传请求头部，交给服务端校验权限、文件名称合法性，如果符合，返回100，客户端再传输剩下的数据。否则返回400之类的错误，直接终止服务 |
| 200        | OK          | 请求成功                                                     |
| 304        | Not Modified          | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会**缓存**访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 400 | Bad Request | 客户端请求的语法错误，服务器无法理解 |
| 401 | Unauthorized      | 请求要求用户的身份认证                   |
| 403 | Forbidden | 服务器理解请求客户端的请求，但是拒绝执行此请求 |
| 404 | Not Found | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405 | Method Not Allowed | 客户端请求中的方法被禁止 |
| 500 | Internal Server Error | 服务器内部错误，无法完成请求                                 |
| 502 | Bad Gateway | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |

## GET和POST

#### 幂等性

GET我们可以理解为**读取**一个资源。比如Get到一个html文件。反复读取不应该对访问的数据有副作用。比如”GET一下，用户就下单了，返回订单已受理“，这是不可接受的。**没有副作用**被称为“幂等“。

由于GET请求为读取，我们可以在浏览器端或者代理端做到**缓存**。

而对于POST，它是不幂等的，也就是说我们不能随意多次执行，也就不能做到缓存。

#### 安全性

貌似GET比POST安全，因为GET把数据全部保存在URL中，然而对攻击者来说，GET、POST都不安全，因为HTTP协议是明文传输的，无论url、headers、body。

## CDN

### 概念

CDN的全称是Content Delivery Network，即**内容分发网络**。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。

### CDN操作

用户通过浏览器指令检索一个特定的资源时，CDN必须截获这个请求，以便能够：

- 确定此时适合用于该客户的CDN服务器集群。
- 将客户的请求重定向到该集群的某一台服务器。

结合下面这个真实案例，我们来了解一下CDN的整个流程，假定一个内容提供商**yuzzl.top**，雇用了第三方CDN公司**七牛云**来向他的客户提供资源。在**yuzzl.top**的网页上，每个资源都被指定了一个URL。

![cdn流程](../assets/images/CDN流程.jpg)

接下来我们来介绍一下**集群选择策略**，这是任何CDN部署的核心。

### 集群选择策略

集群的选择对应了上图的**步骤4**，在CDN权威服务器得知了本地DNS服务器的地址之后，CDN需要基于该地址选择一个适当的集群。CDN一般采用专用的集群选择策略。常见的方案有：

#### 地理上最为临近

使用商用地理位置数据库，每个本地DNSIP地址都映射到某个地理位置。CDN通过数据库的查询找到地理位置上最为接近的集群。

#### 实时测量

**地理上最为临近**的方案对于众多用户来说表现得很好，但是对于部分用户，不一定起到最好效果。因为**地理最邻近的集群可能并不是沿着网络路径最近的集群**。另外，还有可能用户的本地DNS的地理位置距离客户的位置比较大，导致我们地理位置的判断失去意义。

CDN可以通过对其集群和客户之间的时延和丢包性能执行周期性的实时测量。

针对实时测量，我们有以下几种常见方案。

- 让CDN能够让它的集群周期性地向位于全世界的所有本地DNS发送探测分组（例如ping报文）。缺点在于部分本地DNS拒绝来自CDN服务器的探测。
- 利用近期客户和CDN服务器的交互信息来进行测量。缺点在于时不时地需要将用户重定向到优化过的集群。从而导致性能下降。

## HTTP缓存

### 流程

浏览器加载一个页面的简单流程如下：

- 浏览器先根据这个资源的http头信息来判断**是否命中强缓存**。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。
- 如果未命中强缓存，则浏览器会将**资源加载请求**发送到服务器。**服务器来判断**浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器**继续从缓存加载资源**。
- 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。

### 强制缓存

#### 图解

### ![强制缓存](../assets/images/强制缓存.png)

#### 实现相关

强制缓存的实现依靠下面这几个请求头：

##### Cache-Control

这个首部可能的值如下：

- **private** 客户端可以缓存
- **public** 客户端和代理服务器都可以缓存
- **max-age=x** 缓存内容将在x秒后失效
- **no-cache** 需要使用对比缓存验证数据,强制向源服务器再次验证  (没有强制缓存)
- **no-store** 所有内容都不会缓存，强制缓存和对比缓存都不会触发 (不缓存)

##### Expires

Expires: [一个 HTTP-日期 时间戳],  表示在此时候之后，响应过期。

如果在`Cache-Control`响应头设置了 "max-age" 或者 "s-max-age" 指令，那么 `Expires` 头会被忽略。

### 对比缓存（协商缓存）

#### 图解

![协商缓存](../assets/images/协商缓存.png)

#### 实现相关

##### Last-Modified 

包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。

##### If-Modified-Since 

服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为**200**。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的**304**响应

##### ETag 

ETag是URL的tag，用来标示URL对象是否改变。这样可以应用于客户端的缓存：服务器产生ETag，并在HTTP响应头中将其传送到客户端，服务器用它来判断页面是否被修改过，如果未修改返回304，无需传输整个对象。

##### If-None-Match

对于 GET 和 HEAD 请求方法来说，当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为200。对于其他方法来说，当且仅当最终确认没有已存在的资源的  **ETag** 属性值与这个首部中所列出的相匹配的时候，才会对请求进行相应的处理。

上面这些请求头的解释来自MDN文档，看完之后可能感到云里雾里的，下面我们来访问一个资源进行实践，会逐一详细讲解。

#### 缓存实践

请看下图，这是访问jsdelivrCDN的moment.js库的请求头（之前已经访问过一次）地址为: https://cdn.jsdelivr.net/npm/moment@2.27.0/min/moment.min.js

![缓存实战](../assets/images/缓存实战.png)

详细的解释如下：

- 本次返回的状态码为**304**，说明无需再次传输请求的内容，也就是说可以使用缓存的内容。
- **cache-control**:  public, max-age=31536000, s-maxage=31536000, immutable，其中：
  - public 表示响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。
  - max-age表示超过31536000s之后缓存被认为过期
  - s-maxage 仅适用于共享缓存(比如各个代理)，私有缓存会忽略它
  - immutable 如果没有超过时间上的过期失效时间，那么服务器端该页面内容将不会改变，这样浏览器就不应该再发送有条件的重新验证请求。简而言之，可以理解为阻止了无意义的条件请求。

- **Etag** 和 **If-None-Match**：当浏览器请求上面的js文件时, 服务器根据A算出一个哈希e5ee-zUVI2arEgtR9ThZVMK3qTcnqNck并通过 ETag 返回给浏览器，浏览器把这个hash值和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 If-None-Match: "e5ee-zUVI2arEgtR9ThZVMK3qTcnqNck" 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返回的值做比较，来判断是直接返回资源还是使用缓存。

## HTTP和HTTPS

## DOS攻击

**DOS**是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。*[百度百科]*

### 类型

大多数DOS攻击包括以下三种类型：

- 弱点攻击。利用被攻击主机所提供服务程序或传输协议的本身实现缺陷，反复发送畸形的攻击数据引发系统错误的分配大量系统资源，使主机处于挂起状态甚至死机。
- 带宽洪泛。制造大流量无用数据，造成通往被攻击主机的网络拥塞，使被攻击主机无法正常和外界通信。
- 连接洪泛。攻击者在目标主机中创建大量的半开或者全开TCP连接，该主机由于这些伪造的连接陷入困境，并停止接收合法的连接。

> 类似的，还有一种攻击叫做**DDOS**，是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为**分布式拒绝服务攻击**，其中的攻击者可以有多个。

### 防范



## WebSocket

### 经典轮询

很多网站为了实现推送技术，所用的技术都是 **Ajax 轮询**。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。

### 介绍

Web Socket的目标是通过一个长时连接实现与服务器全双工、双向的通信，一般的HTTP协议只能通过客户端主动向服务端发起请求，而webSocket可以主动向客户端发送信息。只要**通过一次握手**，就可以实现双向推送。它和HTTP Server共享同一port。

### 和HTTP协议的区别

下面的内容来自https://tools.ietf.org/html/rfc6455#section-1.7

- The WebSocket Protocol is an independent **TCP-based** protocol.
- Its **only relationship** to HTTP is that its **handshake is interpreted by HTTP servers** as an Upgrade request.
- By default, the WebSocket Protocol uses **port 80** for regular WebSocket connections and **port 443** for WebSocket connections tunneled over Transport Layer Security (TLS) *[RFC2818]*.

> websocket协议是独立于基于TCP的协议的。
>
> 它和HTTP协议的唯一关系是它的握手流程是通过HTTP协议来实现的。
>
> 在默认情况下，websocket协议使用80端口（常规模式）或者443端口（安全传输模式下）

### 实现细节

#### 打开连接-握手

若要实现WebSocket协议，首先需要浏览器主动发起一个**HTTP请求**, 下面是一个请求报文示例，多余的内容被省略。

```http
GET wss://xxxxx.com/ HTTP/1.1
Upgrade: websocket
Sec-WebSocket-Key: CENNKlxp+sYCvqt3pK2T1A==
```

请求头中有一个`Upgrade`字段，内容为`websocket`, 用于改变HTTP协议版本或换用其他协议，这里显然是换用了Websocket协议。还有一个最重要的字段`Sec-WebSocket-Key`，这是一个随机的经过`base64`编码的字符串，像密钥一样用于服务器和客户端的握手过程。服务器君接收到来自客户端的`upgrade`请求，便会将请求头中的`Sec-WebSocket-Key`字段提取出来，追加一个固定的“魔串”：`258EAFA5-E914-47DA-95CA-C5AB0DC85B11`，并进行`SHA-1`加密，然后再次经过`base64`编码生成一个新的key，作为响应头中的`Sec-WebSocket-Accept`字段的内容返回给浏览器。一旦浏览器接收到来自服务器的响应，便会解析响应中的`Sec-WebSocket-Accept`字段，与自己加密编码后的串进行匹配，一旦匹配成功，便有建立连接的可能了（因为还依赖许多其他因素）。

下面是一个响应报文案例，多余的内容被省略。

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Sec-WebSocket-Version: 13
Connection: Upgrade
Sec-WebSocket-Accept: 7d3Wyy9mojKdk/q0gH2A/xvwNV8=
```

### 实践

主流浏览器支持`websocket`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Title</title>
  </head>
  <body>
    <script>
      const SOCKET_URL = "wss://socket.idcd.com:1443";
      const webSocket = () => {
        // 浏览器会在初始化 WebSocket 对象之后立即创建连接
        let socket = new WebSocket(SOCKET_URL);

        // socket 连接成功 发送信息
        socket.onopen = () => {
          socket.send("hello world");
        }
      }
      webSocket();
    </script>
  </body>
</html>
```

浏览器开发者模式抓包：

![](../assets/images/websocket报文.png)

来看一下发起连接的报文：

- 状态码为**101**。101表示等待，服务器收到请求，需要**请求者继续执行操作**。经过这样的请求-响应处理后，两端的WebSocket连接握手成功, 后续就可以进行TCP通讯了。
- **Sec-WebSocket-Version** 表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。
- **Sec-WebSocket-Key** 对应服务端响应头的Sec-WebSocket-Accept，由于没有同源限制，websocket客户端可任意连接支持websocket的服务。这个就相当于一个钥匙一把锁，避免多余的，无意义的连接。
- **Sec-WebSocket-Accept**: 用来告知服务器愿意发起一个websocket连接， 值根据客户端请求头的Sec-WebSocket-Key计算出来。

尝试发送一条消息：

```javascript
socket.send("hello world");
```

![](../assets/images/websocket发送消息.jpg)



### 实现一个Websocket服务器

TODO