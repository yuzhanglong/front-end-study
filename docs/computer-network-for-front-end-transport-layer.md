---
date: 2021-5-2

tags:

- 前端基础
- 计算机网络
---

# 前端计算机网络基础(传输层)

[[toc]]

## TCP

### TCP 报文首部格式

![](http://cdn.yuzzl.top/blog/20201105214030.png)

**源端口和目的端口**：各占两个字节，分别写入源端口号和目的端口号。

**序号**：占 4 个字节，用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

**确认号**：占 4 个字节，期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

**数据偏移**：占 4 位，指的是数据部分距离报文段起始处的偏移量，实际上指的是**首部的长度**。

**确认 ACK**：当 `ACK=1` 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

**同步 SYN**：在连接建立时用来同步序号。当 `SYN=1`，`ACK=0` 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 `SYN=1`，`ACK=1`。

**终止 FIN**：用来释放一个连接，当 `FIN=1` 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

**窗口**：占 2 字节，窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

**检验和**：占 2 个字节，检验和字段检验的范围包括首部和数据这两个部分。在计算检验和时，在 TCP 报文段的前面加上 12 字节的伪首部，伪首部仅在计算检验和时起作用，并不会传递给网络层。

### TCP 如何保证可靠传输

#### 停止等待 ARQ 协议

![](http://cdn.yuzzl.top/blog/20210502200748.png)

![](http://cdn.yuzzl.top/blog/20210502200738.png)

- 第一张图是正常情况下的传输
- 第二张图是接收方为接受到发送方的包，发送方在一定时间后决定重传
- 第三张图接受方的确认包丢失了，基于图 2 的机制，发送方的超时重传被触发，接收方再次收到 M1，并丢弃旧的 M1
- 第四张图对迟到的确认进行忽略处理

:::tip 若一个包重传 N 次还是失败，会一直重传到成功为止吗？

这取决于系统的设置，例如一些系统重传 5 次还未成功就会发送 reset 报文（RST）断开 TCP 连接
:::

#### 连续 ARQ 协议与滑动窗口协议

不难看出，停止等待协议效率较低，于是我们有了连续 ARQ 协议与滑动窗口协议。

![](http://cdn.yuzzl.top/blog/20210502143406.png)

下图详细描述了整个机制的流程：

![](http://cdn.yuzzl.top/blog/20210502144526.png)

#### 流量控制

流量控制的意义在于让发送方的发送速率不要太快，让接收方来得及接收处理，请看下图：

![](http://cdn.yuzzl.top/blog/20210502150606.png)

#### 拥塞控制

相对于点对点通信的流量控制，拥塞控制是一个全局性的过程，目的是防止过多的数据流入到网络中，避免负载过大。

其机制分为如下几部分：

- 慢开始
- 拥塞避免
- 快重传
- 快恢复

:::tip 几个概念

- cwnd: 拥塞窗口，这是发送方根据自己估算的网络拥塞程度而设置的窗口值，反应的是当前网络的容量。
- rwnd: 接受窗口，这是接收方根据自己的缓存大小设置的值，并且要告诉发送方，反应接收方的接收能力。
- swnd: 发送窗口，值为 `Math.min(cwnd, rwmd)`，发送的数据既不能超过网络的容量，也不能超过接收方的容量。

:::

**基本流程**

![](http://cdn.yuzzl.top/blog/20210502184511.png)

- 接收方告诉发送方我的接收窗口大小为 3000。
- 发送方根据自己估算的网络拥塞程度设置 `cwnd` 为一个较小的初始值。
- 在收到相应的确认之后，扩展发送窗口（拥塞窗口也随之扩展） -- 指数级增长。
- 到一个阈值 `ssthresh`（慢开始门限） 时，改为线性增长，此过程称为拥塞避免。
- 一旦出现网络拥塞，我们把 `ssthresh` 降为原来的一半，同时执行慢开始算法。

上述流程总结如下：

![](http://cdn.yuzzl.top/blog/20210502191220.png)

:::tip

上图的算法基于 TCP Tahoe 版本，现在已经弃用，广泛使用的是 TCP Reno 版本，其示意图如下，不难看出，新的算法在回复的之后会直接从 `ssthresh / 2` 处线性增长：

![](http://cdn.yuzzl.top/blog/20210502191946.png)

:::

### TCP 三次握手

#### 过程分析

TCP 连接是通过主机 A 和主机 B 之间的三次握手建立的。下面以文字加上抓包截图的方式来正确理解整个过程。

![](http://cdn.yuzzl.top/blog/20201105184801.png)

- 第一次握手：主机 A 向主机 B 发送一个报文，表示 A 处的 TCP 层希望和 B 的 TCP 层建立连接。这个报文也被称为**SYN 消息**（synchronize，同步的简写）。另外 A 会随机选择一个初始序号（`seq=client_isn`）一起交给 B。

![](http://cdn.yuzzl.top/blog/20201105191649.png)

- 第二次握手：B 收到数据包后由标志位`SYN=1`知道 A 请求建立连接，B 将**标志位** `SYN` 和 `ACK` 都置为 1，`ack = client_isn + 1`, 随机产生一个值 `seq = server_isn`。

![](http://cdn.yuzzl.top/blog/20201105191818.png)

- 第三次握手：A 收到确认后，检查 ack 是否为`client_isn + 1`，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，`ack = server_isn + 1`，并将该数据包发送给 B，B 检查 ack 是否为 `server_isn + 1`，ACK 是否为 1，如果正确则连接建立成功，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。

![](http://cdn.yuzzl.top/blog/20201105191908.png)

#### 为什么需要三次握手

我们需要知道 TCP 握手握的是什么 -- **通信双方数据原点的序列号**。

- A --> B  `SYN` + `A序列号`
- B --> A  `SYN` + `B序列号`（同时记录 A 的序列号到本地）
- A --> B （同时记录 B 的序列号到本地）

经过三次握手，双方都可以获得对面的序列号并存到本地。并且都确认自己收到了对方的同步信号。

##### 如果是两次握手呢

- A --> B SYN + A 序列号
- B --> A SYN + B 的序列号

两人的序列号达成了一致，但是**B 不知道 A 能否接收到自己的同步信号**，如果这个同步信号丢失了，A 和 B 就 B 的初始序列号将无法达成一致。

### TCP 四次挥手

#### 过程分析

![](http://cdn.yuzzl.top/blog/20201105190758.png)

- 第一次挥手：客户端设置 seq 和 ACK ,向服务器发送一个 FIN 报文段。此时，客户端进入 FIN_WAIT_1 状态，表示客户端没有数据要发送给服务端了。

![](http://cdn.yuzzl.top/blog/20201105192914.png)

- 第二次挥手，服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。

![](http://cdn.yuzzl.top/blog/20201105193031.png)

- 第三次挥手，服务端向客户端发送 FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。

![](http://cdn.yuzzl.top/blog/20201105193406.png)

- 第四次挥手，客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段, 然后客户端进入 TIME_WAIT 状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待 2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。

![](http://cdn.yuzzl.top/blog/20201105193510.png)

#### 为什么需要四次挥手

第一次挥手，表示主动方不会再发送数据报文，但是主动方还是可以接收的。

第二次挥手被动还有可能有数据报文需要发送，所以需要先发送 ACK 报文，告诉主动方“我知道你想断开连接的请求了”。这样主动便不会因为没有收到应答而继续发送断开连接的请求（即 FIN 报文）。

所以关键问题在于有可能**被动方接收到断开连接的请求时，手里还有活没做完**。

## TCP 和 UDP 的区别

- TCP 面向连接，UDP 无连接
- TCP 是可靠传输，UDP 尽可能交付，但不保证到达，可能丢包
- TCP 的首部占用空间大，UDP 小
- TCP 传输速率慢，UDP 慢
- TCP 应用于浏览器、文件传输、邮件发送，UDP 应用于音视频通话、直播