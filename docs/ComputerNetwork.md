# 计算机网络

参考资料：

- https://www.runoob.com/html/html5-websocket.html
- https://blog.csdn.net/wx_962464/article/details/51043069
- https://www.zhihu.com/question/338939262/answer/778573750
- https://github.com/abbshr/abbshr.github.io/issues/22
- https://github.com/kaola-fed/blog/issues/271
- https://zhuanlan.zhihu.com/p/26757514
- https://www.upyun.com/tech/article/227/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%20HTTP%2F2%20%E7%89%B9%E6%80%A7.html
- https://www.zhihu.com/question/24853633

## SSL

### 总述

SSL称为**安全套接字协议**，是为网络通信提供安全及数据完整性的一种安全协议。SSL在传输层与应用层之间对网络连接进行加密。位于端口**443**。

### 对称加密和非对称加密

我们要想了解SSL，首先得了解对称加密和非对称加密。

#### 对称加密

##### 描述

需要对加密和解密使用相同密钥的加密算法。

例如：

假设有一个加密算法A, 这个算法将每一位的ASCII码加2形成密文。

用户甲: 明文 ABCD  **-- 加密 -->**  密文 CDEF 

用户乙: 密文CDEF  **-- 解密 -->**  明文 ABCD

我们可以发现，对称加密需要对加密和解密使用相同密钥（可以看成加解密的指令）的加密算法。它的安全性去决议加密算法和密钥的管理。

##### 优缺点

效率高，由于不适合在网上传输，秘钥的维护较为麻烦。

#### 非对称加密

##### 描述

非对称加密算法需要两个密钥：公开密钥（publickey，简称公钥）和私有密钥（privatekey，简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

例如：

- A要向B发送信息，A和B都要产生一对用于加密和解密的**公钥和私钥**。
- A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。
- A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。
- A将这个消息发给B（已经用B的公钥加密消息）
- B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。

##### 优缺点

有较高的安全性，但效率低。

一个优化方案是**结合对称加密算法**，例如如果数据比较大，使用对方的公钥来加密效率会很低，但是我们可以使用对称秘钥，但是使用对方的公钥来加密这个对称秘钥，就可以提高效率（因为加密这个数据量不算大的公钥效率高），这些描述可以概括为“**给锁上锁**”。

### SSL的过程

上面说到，SSL在传输层与应用层之间对网络连接进行加密。

在发送方，SSL接收应用层的数据，对数据进行加密，然后把加密的数据送往TCP套接字。

在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层。

浏览器在访问web服务器的资源时，安装了**证书**的web服务器会交给浏览器一个公钥，之后浏览器生成一个对称加密秘钥，然后用web服务器的公钥进行加密，web服务器可以对这个对称加密秘钥进行解密。在此之后，浏览器和web服务器就通过这个对称加密秘钥来通信。

 ### 数字证书

#### 总述

对于请求方来说，它怎么能确定它所得到的公钥一定是从目标主机那里发布的，而且没有被篡改过呢？亦或者请求的目标主机本本身就从事窃取用户信息的不正当行为呢？这时候，我们需要有一个权威的值得信赖的第三方机构(一般是由政府审核并授权的机构)来统一对外发放主机机构的公钥，只要请求方这种机构获取公钥，就避免了上述问题的发生。

#### 颁发过程

用户首先**产生自己的密钥对**，并将公共密钥及部分个人身份信息传送给认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个**数字证书**，该证书内包含**用户的个人信息和他的公钥信息**，同时还附有认证中心的**签名信息**(根证书私钥签名)。用户就可以使用自己的数字证书进行相关的各种活动。数字证书由独立的证书发行机构发布，数字证书各不相同，每种证书可提供不同级别的可信度。

#### 如何验证

浏览器/操作系统默认内置了CA的根证书。根证书包含了这个CA的公钥。

如果:

- 证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书

- 如果伪造的证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。用CA的公钥，对伪造的证书的摘要进行解密，发现解不了, 认为是危险证书。

- 对于篡改的证书，使用CA的公钥对数字签名进行解密得到摘要A,然后再根据签名的Hash算法计算出证书的摘要B，对比A与B，若相等则正常，若不相等则是被篡改过的。

- 证书可在其过期前被吊销，通常情况是该证书的私钥已经失密。较新的浏览器如Chrome、Firefox、Opera和Internet Explorer都实现了在线证书状态协议（OCSP）以排除这种情形：浏览器将网站提供的证书的序列号通过OCSP发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。

## HTTP状态码

### 分类

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型。

| 分类 | 分类描述                                           |
| :--- | :------------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要**请求者继续执行操作**   |
| 2**  | **成功**，操作被成功接收并处理                     |
| 3**  | **重定向**，需要进一步的操作以完成请求             |
| 4**  | **客户端错误**，请求包含语法错误或无法完成请求     |
| 5**  | **服务器错误**，服务器在处理请求的过程中发生了错误 |

### 常见的状态码

| HTTP状态码 | 英文名称      | 中文描述                                                     |
| :--------- |------------------------ | :----------------------------------------------------------- |
| 100 | Continue | 客户端征询服务器状况，如果服务器同意可以返回100，同时客户端可以继续请求。常见的案例是在上传大文件的情况下，客户端先上传请求头部，交给服务端校验权限、文件名称合法性，如果符合，返回100，客户端再传输剩下的数据。否则返回400之类的错误，直接终止服务 |
| 200        | OK          | 请求成功                                                     |
| 304        | Not Modified          | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会**缓存**访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 400 | Bad Request | 客户端请求的语法错误，服务器无法理解 |
| 401 | Unauthorized      | 请求要求用户的身份认证                   |
| 403 | Forbidden | 服务器理解请求客户端的请求，但是拒绝执行此请求 |
| 404 | Not Found | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405 | Method Not Allowed | 客户端请求中的方法被禁止 |
| 500 | Internal Server Error | 服务器内部错误，无法完成请求                                 |
| 502 | Bad Gateway | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |

## GET和POST

#### 幂等性

GET我们可以理解为**读取**一个资源。比如Get到一个html文件。反复读取不应该对访问的数据有副作用。比如”GET一下，用户就下单了，返回订单已受理“，这是不可接受的。**没有副作用**被称为“幂等“。

由于GET请求为读取，我们可以在浏览器端或者代理端做到**缓存**。

而对于POST，它是不幂等的，也就是说我们不能随意多次执行，也就不能做到缓存。

#### 安全性

貌似GET比POST安全，因为GET把数据全部保存在URL中，然而对攻击者来说，GET、POST都不安全，因为HTTP协议是明文传输的，无论url、headers、body。

## CDN

### 概念

CDN的全称是Content Delivery Network，即**内容分发网络**。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。

### CDN操作

用户通过浏览器指令检索一个特定的资源时，CDN必须截获这个请求，以便能够：

- 确定此时适合用于该客户的CDN服务器集群。
- 将客户的请求重定向到该集群的某一台服务器。

结合下面这个真实案例，我们来了解一下CDN的整个流程，假定一个内容提供商**yuzzl.top**，雇用了第三方CDN公司**七牛云**来向他的客户提供资源。在**yuzzl.top**的网页上，每个资源都被指定了一个URL。

![](http://cdn.yuzzl.top/blog/20201101223427.png)

接下来我们来介绍一下**集群选择策略**，这是任何CDN部署的核心。

### 集群选择策略

集群的选择对应了上图的**步骤4**，在CDN权威服务器得知了本地DNS服务器的地址之后，CDN需要基于该地址选择一个适当的集群。CDN一般采用专用的集群选择策略。常见的方案有：

#### 地理上最为临近

使用商用地理位置数据库，每个本地DNSIP地址都映射到某个地理位置。CDN通过数据库的查询找到地理位置上最为接近的集群。

#### 实时测量

**地理上最为临近**的方案对于众多用户来说表现得很好，但是对于部分用户，不一定起到最好效果。因为**地理最邻近的集群可能并不是沿着网络路径最近的集群**。另外，还有可能用户的本地DNS的地理位置距离客户的位置比较大，导致我们地理位置的判断失去意义。

CDN可以通过对其集群和客户之间的时延和丢包性能执行周期性的实时测量。

针对实时测量，我们有以下几种常见方案。

- 让CDN能够让它的集群周期性地向位于全世界的所有本地DNS发送探测分组（例如ping报文）。缺点在于部分本地DNS拒绝来自CDN服务器的探测。
- 利用近期客户和CDN服务器的交互信息来进行测量。缺点在于时不时地需要将用户重定向到优化过的集群。从而导致性能下降。

## HTTP缓存

### 流程

浏览器加载一个页面的简单流程如下：

- 浏览器先根据这个资源的http头信息来判断**是否命中强缓存**。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。
- 如果未命中强缓存，则浏览器会将**资源加载请求**发送到服务器。**服务器来判断**浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器**继续从缓存加载资源**。
- 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。

### 强制缓存

#### 图解

 ![](http://cdn.yuzzl.top/blog/20201101223609.png)

#### 实现相关

强制缓存的实现依靠下面这几个请求头：

##### Cache-Control

这个首部可能的值如下：

- **private** 客户端可以缓存
- **public** 客户端和代理服务器都可以缓存
- **max-age=x** 缓存内容将在x秒后失效
- **no-cache** 需要使用对比缓存验证数据,强制向源服务器再次验证  (没有强制缓存)
- **no-store** 所有内容都不会缓存，强制缓存和对比缓存都不会触发 (不缓存)

##### Expires

Expires: [一个 HTTP-日期 时间戳],  表示在此时候之后，响应过期。

如果在`Cache-Control`响应头设置了 "max-age" 或者 "s-max-age" 指令，那么 `Expires` 头会被忽略。

### 对比缓存（协商缓存）

#### 图解

![](http://cdn.yuzzl.top/blog/20201101223649.png)

#### 实现相关

##### Last-Modified 

包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。

##### If-Modified-Since 

服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为**200**。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的**304**响应

##### ETag 

ETag是URL的tag，用来标示URL对象是否改变。这样可以应用于客户端的缓存：服务器产生ETag，并在HTTP响应头中将其传送到客户端，服务器用它来判断页面是否被修改过，如果未修改返回304，无需传输整个对象。

##### If-None-Match

对于 GET 和 HEAD 请求方法来说，当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为200。对于其他方法来说，当且仅当最终确认没有已存在的资源的  **ETag** 属性值与这个首部中所列出的相匹配的时候，才会对请求进行相应的处理。

上面这些请求头的解释来自MDN文档，看完之后可能感到云里雾里的，下面我们来访问一个资源进行实践，会逐一详细讲解。

#### 缓存实践

请看下面的报文。（访问jsdelivrCDN的moment.js库）（之前已经访问过一次）地址为: https://cdn.jsdelivr.net/npm/moment@2.27.0/min/moment.min.js

![](http://cdn.yuzzl.top/blog/20201108181236.png)

详细的解释如下：

- 本次返回的状态码为**304**，说明无需再次传输请求的内容，也就是说可以使用缓存的内容。
- **cache-control**:  public, max-age=31536000, s-maxage=31536000, immutable，其中：
  - public 表示响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。
  - max-age表示超过31536000s之后缓存被认为过期
  - s-maxage 仅适用于共享缓存(比如各个代理)，私有缓存会忽略它
  - immutable 如果没有超过时间上的过期失效时间，那么服务器端该页面内容将不会改变，这样浏览器就不应该再发送有条件的重新验证请求。简而言之，可以理解为阻止了无意义的条件请求。

- **Etag** 和 **If-None-Match**：当浏览器请求上面的js文件时, 服务器根据A算出一个哈希e5ee-zUVI2arEgtR9ThZVMK3qTcnqNck并通过 ETag 返回给浏览器，浏览器把这个hash值和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 If-None-Match: "e5ee-zUVI2arEgtR9ThZVMK3qTcnqNck" 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返回的值做比较，来判断是直接返回资源还是使用缓存。

## HTTP和HTTPS



## DOS攻击

**DOS**是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。*[百度百科]*

### 类型

大多数DOS攻击包括以下三种类型：

- 弱点攻击。利用被攻击主机所提供服务程序或传输协议的本身实现缺陷，反复发送畸形的攻击数据引发系统错误的分配大量系统资源，使主机处于挂起状态甚至死机。
- 带宽洪泛。制造大流量无用数据，造成通往被攻击主机的网络拥塞，使被攻击主机无法正常和外界通信。
- 连接洪泛。攻击者在目标主机中创建大量的半开或者全开TCP连接，该主机由于这些伪造的连接陷入困境，并停止接收合法的连接。

> 类似的，还有一种攻击叫做**DDOS**，是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为**分布式拒绝服务攻击**，其中的攻击者可以有多个。

### 防范



## WebSocket

### 经典轮询

很多网站为了实现推送技术，所用的技术都是 **Ajax 轮询**。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。

### 介绍

Web Socket的目标是通过一个长时连接实现与服务器全双工、双向的通信，一般的HTTP协议只能通过客户端主动向服务端发起请求，而webSocket可以主动向客户端发送信息。只要**通过一次握手**，就可以实现双向推送。它和HTTP Server共享同一port。

### 和HTTP协议的区别

下面的内容来自https://tools.ietf.org/html/rfc6455#section-1.7

- The WebSocket Protocol is an independent **TCP-based** protocol.
- Its **only relationship** to HTTP is that its **handshake is interpreted by HTTP servers** as an Upgrade request.
- By default, the WebSocket Protocol uses **port 80** for regular WebSocket connections and **port 443** for WebSocket connections tunneled over Transport Layer Security (TLS) *[RFC2818]*.

> websocket协议是独立于基于TCP的协议的。
>
> 它和HTTP协议的唯一关系是它的握手流程是通过HTTP协议来实现的。
>
> 在默认情况下，websocket协议使用80端口（常规模式）或者443端口（安全传输模式下）

### 实现细节

#### 打开连接-握手

若要实现WebSocket协议，首先需要浏览器主动发起一个**HTTP请求**, 下面是一个请求报文示例，多余的内容被省略。

```http
GET wss://xxxxx.com/ HTTP/1.1
Upgrade: websocket
Sec-WebSocket-Key: CENNKlxp+sYCvqt3pK2T1A==
```

请求头中有一个`Upgrade`字段，内容为`websocket`, 用于改变HTTP协议版本或换用其他协议，这里显然是换用了Websocket协议。还有一个最重要的字段`Sec-WebSocket-Key`，这是一个随机的经过`base64`编码的字符串，像密钥一样用于服务器和客户端的握手过程。服务器君接收到来自客户端的`upgrade`请求，便会将请求头中的`Sec-WebSocket-Key`字段提取出来，追加一个固定的“魔串”：`258EAFA5-E914-47DA-95CA-C5AB0DC85B11`，并进行`SHA-1`加密，然后再次经过`base64`编码生成一个新的key，作为响应头中的`Sec-WebSocket-Accept`字段的内容返回给浏览器。一旦浏览器接收到来自服务器的响应，便会解析响应中的`Sec-WebSocket-Accept`字段，与自己加密编码后的串进行匹配，一旦匹配成功，便有建立连接的可能了（因为还依赖许多其他因素）。

下面是一个响应报文案例，多余的内容被省略。

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Sec-WebSocket-Version: 13
Connection: Upgrade
Sec-WebSocket-Accept: 7d3Wyy9mojKdk/q0gH2A/xvwNV8=
```

### 实践：webSocket API 

主流浏览器支持`websocket`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Title</title>
  </head>
  <body>
    <script>
      const SOCKET_URL = "wss://socket.idcd.com:1443";
      const webSocket = () => {
        // 浏览器会在初始化 WebSocket 对象之后立即创建连接
        let socket = new WebSocket(SOCKET_URL);

        // socket 连接成功 发送信息
        socket.onopen = () => {
          socket.send("hello world");
        }
      }
      webSocket();
    </script>
  </body>
</html>
```

浏览器开发者模式抓包：

![](http://cdn.yuzzl.top/blog/20201101224250.png)

来看一下发起连接的报文：

- 状态码为**101**。101表示等待，服务器收到请求，需要**请求者继续执行操作**。经过这样的请求-响应处理后，两端的WebSocket连接握手成功, 后续就可以进行TCP通讯了。
- **Sec-WebSocket-Version** 表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。
- **Sec-WebSocket-Key** 对应服务端响应头的Sec-WebSocket-Accept，由于没有同源限制，websocket客户端可任意连接支持websocket的服务。这个就相当于一个钥匙一把锁，避免多余的，无意义的连接。
- **Sec-WebSocket-Accept**: 用来告知服务器愿意发起一个websocket连接， 值根据客户端请求头的Sec-WebSocket-Key计算出来。

尝试发送一条消息：

```javascript
socket.send("hello world");
```

![](http://cdn.yuzzl.top/blog/20201101224312.png)

### 实践：实现一个Websocket服务器

**TODO**



## DNS

### 概念

DNS解析其实就是用你的域名来定位真正的IP地址，就像拜访朋友要先知道别人家怎么走一样，Internet上当一台主机要访问另外一台主机时，必须首先获知其地址，TCP/IP中的IP地址是由四段以“.”分开的数字组成，记起来总是不如名字那么方便，所以，就采用了**DNS**来管理名字和IP的对应关系。

### 流程

DNS解析本质上是一个**迭代查询**和**递归查询**的过程，假设我的主机要访问`docs.yuzzl.top`这个网站，需要获得它的IP，来看看这个DNS解析流程：
![](http://cdn.yuzzl.top/blog/20201108194011.png)

### DNS缓存
当某DNS服务器接收到一个应答之后，它会将这个内容缓存到服务器上。还是上面的图，假如另一台电脑使用同样的本地DNS服务器访问`docs.yuzzl.top`，那么本地DNS服务器查询缓存，然后直接返回`docs.yuzzl.top`的IP地址（如果没有过期的话）。

## HTTP版本区别

### 1.0 VS 1.1

#### 长连接

**HTTP1.1**支持**长连接**和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接`keep-alive`，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用`keep-alive`参数来告知服务器端要建立一个长连接。

#### 带宽优化

**HTTP1.1**支持只发送`header`信息，如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器。

#### 缓存处理

- **HTTP1.0**：If-Modified-Since, Expires

- **HTTP1.1**：Entity tag，If-Unmodified-Since, If-Match, If-None-Match

> 关于缓存的详细内容参考：<a href="#HTTP缓存">HTTP缓存</a>

### 1.1 VS 2.0

#### 二进制分帧

HTTP/1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为**更小的帧**，并且它们采用二进制编码。   

#### 多路复用

##### HTTP1.x多路并行的弊端

下图中（HTTP1.x）红色部分因为浏览器域名链接数的个数限制导致等待。

![](http://cdn.yuzzl.top/blog/20201101224805.png)

##### HTTP2.x实现多流并行

在 HTTP/2 中，有了二进制分帧之后，HTTP/2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中：

- 同域名下所有通信都在**单个连接上**完成。
- 单个连接可以承载任意数量的双向数据流
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。

##### 我们已经有了keep-alive为什么还要多路复用？

- HTTP 1.1做不到真实的**并行** ---- HTTP 1.1 基于**串行**文件传输数据，因此这些请求必须是**有序的**，所以实际上我们只是节省了建立连接的时间，而获取数据的时间并没有减少。HTTP/2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据。

##### 性能提升的原因

- 同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。
- 单个连接上可以并行交错的请求和响应，之间互不干扰。
- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。

##### 图解多路复用

![](http://cdn.yuzzl.top/blog/v2-b1e608ddb7493608efea3e76912aabe1_b.png)



#### 头部压缩

**HTTP2.0**使用**HPACK算法**对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。

如下图，请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。

![](http://cdn.yuzzl.top/blog/20201101224957.png)

#### 服务端推送（server push）

服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML再发送这些请求。服务端可以主动推送，客户端也有权利选择接收与否。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。

## TCP

### TCP三次握手

#### 过程分析

TCP连接是通过主机A和主机B之间的三次握手建立的。下面以文字加上抓包截图的方式来正确理解整个过程。

![](http://cdn.yuzzl.top/blog/20201105184801.png)

- 第一次握手：主机A向主机B发送一个报文，表示A处的TCP层希望和B的TCP层建立连接。这个报文也被称为**SYN消息**（synchronize，同步的简写）。另外A会随机选择一个初始序号（`seq=client_isn`）一起交给B。

  ![](http://cdn.yuzzl.top/blog/20201105191649.png)



- 第二次握手：B收到数据包后由标志位`SYN=1`知道A请求建立连接，B将**标志位**`SYN`和`ACK`都置为1，`ack = client_isn + 1`, 随机产生一个值`seq = server_isn`。

![](http://cdn.yuzzl.top/blog/20201105191818.png)

- 第三次握手：A收到确认后，检查ack是否为`client_isn + 1`，ACK是否为1，如果正确则将标志位ACK置为1，`ack = server_isn + 1`，并将该数据包发送给B，B检查ack是否为`server_isn + 1`，ACK是否为1，如果正确则连接建立成功，完成三次握手，随后Client与Server之间可以开始传输数据了。

![](http://cdn.yuzzl.top/blog/20201105191908.png)

#### 为什么需要三次握手？

##### 握手握了什么？

我们需要知道TCP握手握的是什么 -- **通信双方数据原点的序列号**。

- A --> B  `SYN` + `A序列号`
- B --> A  `SYN` + `B序列号`（同时记录A的序列号到本地）
- A --> B （同时记录B的序列号到本地）

经过三次握手，双方都可以获得对面的序列号并存到本地。并且都确认自己收到了对方的同步信号。

##### 如果是两次握手呢？

- A --> B SYN + A序列号
- B --> A SYN + B 的序列号

两人的序列号达成了一致，但是**B不知道A能否接收到自己的同步信号**，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。

### TCP四次挥手

#### 过程分析

![](http://cdn.yuzzl.top/blog/20201105190758.png)

- 第一次挥手：客户端设置seq和 ACK ,向服务器发送一个 FIN(终结)报文段。此时，客户端进入 FIN_WAIT_1状态，表示客户端没有数据要发送给服务端了。

![](http://cdn.yuzzl.top/blog/20201105192914.png)

- 第二次挥手，服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。

![](http://cdn.yuzzl.top/blog/20201105193031.png)

- 第三次挥手，服务端向客户端发送FIN报文段，请求关闭连接，同时服务端进入LAST_ACK状态。

![](http://cdn.yuzzl.top/blog/20201105193406.png)

- 第四次挥手，客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段, 然后客户端进入 TIME_WAIT状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。

![](http://cdn.yuzzl.top/blog/20201105193510.png)

#### 为什么需要四次挥手？

第一次挥手，表示主动方不会再发送数据报文，但是主动方还是可以接收的。

第二次挥手被动还有可能有数据报文需要发送，所以需要先发送ACK报文，告诉主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。

所以关键问题在于有可能**被动方接收到断开连接的请求时，手里还有活儿没做完**。

### TCP报文首部格式

![](http://cdn.yuzzl.top/blog/20201105214030.png)

**源端口和目的端口 :** 各占两个字节，分别写入源端口号和目的端口号。

**序号 ：** 占4个字节；用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

**确认号 ：** 占4个字节；期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

**数据偏移 ：**占4位；指的是数据部分距离报文段起始处的偏移量，实际上指的是**首部的长度**。

**确认 ACK ：** 当 `ACK=1`时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

**同步 SYN** ：在连接建立时用来同步序号。当 `SYN=1`，`ACK=0` 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 `SYN=1`，`ACK=1`。

**终止 FIN ：** 用来释放一个连接，当 `FIN=1` 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
**窗口 ：** 占2字节；窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。
**检验和：** 占2个字节；检验和字段检验的范围包括首部和数据这两个部分。在计算检验和时，在TCP报文段的前面加上12字节的伪首部。